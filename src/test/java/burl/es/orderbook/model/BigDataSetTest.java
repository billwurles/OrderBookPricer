package burl.es.orderbook.model;

import burl.es.orderbook.model.exceptions.OrderNotFoundException;
import burl.es.orderbook.model.exceptions.OrderParseException;
import burl.es.orderbook.model.order.OrderSnapshot;
import burl.es.orderbook.model.order.ReduceSnapshot;
import burl.es.orderbook.model.order.Side;
import org.junit.jupiter.api.Test;
import org.springframework.core.io.ClassPathResource;

import java.io.IOException;
import java.util.Scanner;

import static org.junit.jupiter.api.Assertions.fail;

public class BigDataSetTest {

    OrderBookController controller = new OrderBookController();

	/* Parses order strings in the format
	timestamp 	The time when this message was generated by the market, as milliseconds since midnight.
	A 			literal string identifying this as an "Add Order to Book" message.
	order-id 	A unique string that subsequent "Reduce Order" messages will use to modify this order.
	side 		A 'B' if this is a buy order (a bid), and a 'S' if this is a sell order (an ask).
	price 		The limit price of this order.
	size 		The size in shares of this order, when it was initially sent to the market by some stock trader.

	28800538 A b S 44.26 100
    28812071 R f 157
 */

    public static void main(String[] args) {
//        readOrdersFromFile();
//        log.debug("getOrderById max execution time \t hash: {}ns \t binary: {}ns",controller.maxHashTime ,controller.maxBubbleTime);

//        insertOrderToBook("1400000 A a B 30 300");
//        insertOrderToBook("1500000 A b B 31 30");
//        insertOrderToBook("1400000 A c S 29 30");
//        insertOrderToBook("1700000 A d S 28 30");
//        insertOrderToBook("1100000 A e S 31 30");
    }

    public void readOrdersFromFile(String file) throws OrderNotFoundException, IOException {
        Scanner scan = new Scanner(new ClassPathResource(file).getFile());
        while(scan.hasNext()){
            insertOrderToBook(scan.nextLine());
        }
    }

    public void insertOrderToBook(String order) throws OrderNotFoundException {
        String[] parts = order.split(" ");
        switch (parts[1]){
            case "A":
                controller.addOrder(new OrderSnapshot(parts[2], parseOrderSide(parts[3]), parts[4], parts[5]));
                break;
            case "R":
                controller.reduceOrder(new ReduceSnapshot(parts[2], parts[3]));
                break;
        }
    }

    private static Side parseOrderSide(String side) {
        return switch (side) {
            case "B" -> Side.BUY;
            case "S" -> Side.SELL;
            default -> throw new OrderParseException("Unknown A Type '" + side + "'");
        };
    }

//    private static ZonedDateTime parseOrderTimeStamp(long millisSinceMidnight) {
//        try {
//            LocalDateTime todayMidnight = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT);
//            ZonedDateTime zdt = todayMidnight.atZone(ZoneId.of("Europe/London"));
//            long midnightEpoch = zdt.toInstant().toEpochMilli();
//            return ZonedDateTime.ofInstant(Instant.ofEpochMilli(midnightEpoch + millisSinceMidnight), ZoneId.of("Europe/London"));
//        } catch(Exception e){
//            throw new OrderParseException("Timestamp '"+millisSinceMidnight+"' is invalid");
//        }
//    }

    @Test
    void theBigOne(){
        long startTime = System.nanoTime();
        try {
            readOrdersFromFile("price_data_short.txt");
        } catch (Exception e){
            e.printStackTrace();
            fail("Error occurred in the big one");
        }
        long endTime = System.nanoTime();
        long duration = (endTime - startTime) / 100000;
        assert duration < 20000 : "durationSet="+duration; // Shouldn't take longer than 2 seconds, but this should be adjusted for your pc

        //todo: should probably check the result is correct but it would take sooo looooooooooooong to figure out manually so nah
    }
}
